MSA 프로젝트, 커피 주문 시스템 ☕️
================

> 2020년, 팀 프로젝트 서비스의 기능들을 구현하며 하나의 기능에 장애가 났을 때 서비스 전체가 먹통이 되는 점, <br />
> 그리고 이에 따라 서비스의 개선이 어렵고 수정 시 장애의 영향도 파악이 어렵다는 불편함을 느꼈습니다. <br />
> 이러한 문제를 해결하고, 또 추후 서비스가 커졌을 때 부분적인 scale-out이 수월한 ['MSA 아키텍쳐'](https://blog.naver.com/ghdalswl77/222407195800, "msa link") 를 도입해야겠다고 생각했습니다. 그래서 자주 이용하던 스타벅스의 사이렌 오더(커피 주문 시스템)을 MSA 구조로 구현하는 MSA-COFFEE-ORDER 프로젝트를 진행하였습니다. <br />
<br />

## Why MSA?
+ 부분 장애가 전체 서비스로 전파된다.
+ 부분적인 서비스의 scale-out이 어렵다.
+ 서비스의 개선이 어렵고, 수정 시 장애의 영향도 파악이 어렵다. 
+ 서비스의 전체 코드가 하나의 프로젝트로 구성되어 배포가 오래걸린다.
<br />

## MSA 프로젝트의 목표
+ 하나의 서비스 장애가 다른 서비스로 전파되지 않는다.
+ 코드 복잡성 및 의존성을 제거해 영향도 파악을 용이하게 한다.
+ 추후 서비스의 고 가용성과 확장성을 확보한다.

<br />
<hr />

### ⚒ 사용 기술
+ Kubernetes
+ Docker
<hr />

### 📍 프로젝트 전체 구성
<img width="760" alt="msa00" src="https://user-images.githubusercontent.com/68539040/173878465-f58e8db6-4239-4142-94ef-0bf088dca791.png">
<br />
전체 구성도는 위와 같으며, 주요 서비스들은 쿠버네티스 환경에서 각각의 파드들로 동작하고 있고 <br />
서비스 운영 환경과 서비스 개발 환경 총 2개로 구분할 수 있습니다.
<br />
<br />

> 현재 비용 문제로 도메인 사이트 운영 중단된 상태입니다. <br />

<img width="700" alt="msa02" src="https://user-images.githubusercontent.com/68539040/173879867-761f06c8-e4a7-4996-b69c-96ecfd309ca8.png">
카페 점원(admin)이 http://www.minzy-pansy.kro.kr:8080/admin 도메인으로 접속하면, <br />
쿠버네티스 클러스터의 IP로 접속하게 되고, 쿠버네티스 클러스터에서는 8080:8080 포트포워딩을 이용해 sidecar-admin 파드에 연결되도록 설정하였습니다.<br />
그리고 고객(client)은 http://www.minzy-pansy.kro.kr/client 도메인으로 접속하면 쿠버네티스 클러스터의 IP로 접속하게 되고 <br />
쿠버네티스 클러스터에서는 80:8080 포트포워딩을 이용해 sidecar-client 파드에 연결되도록 설정하였습니다.<br />

<br />

<img width="760" alt="msa01" src="https://user-images.githubusercontent.com/68539040/173880429-932e1d36-144e-4ce6-af58-84f6459cf2a4.png"> <br />
<br /> 프론트에 접속한 관리자, 고객은 Ajax를 이용해 Zuul 서버로 API를 호출하게 됩니다. 호출 가능한 API는 다음 표와 같습니다.
<br />
<br />
<img width="760" alt="msa03" src="https://user-images.githubusercontent.com/68539040/173880896-b845fd13-ab4b-4d23-8dde-a5b2383e6bd6.png"> <br />
<br /> 관리자, 고객이 특정 API를 호출하게 되면 Zuul 서버는 Eureka서버에서 API에 해당하는 serviceId를 찾게됩니다.<br />
Eureka 서버에는 각 서비스들이 serviceId와 함께 해당 서비스가 동작하고 있는 서버의 IP주소가 등록되어 있으며<br />
Zuul 서버는 이 ip주소들로 라우팅해주어 각각의 서비스들이 동작하게됩니다.<br /><hr />


### 📍 관리자 페이지

관리자 페이지의 동작 방식 입니다.<br />
관리자가 페이지에 접속하면 고객이 주문한 주문이 화면에 표시되고, 해당 주문의 완료 버튼을 누르면 고객의 화면의 주문내역의 상태가 완료로 변경됩니다. <br />
<br />
<img width="760" alt="msa04" src="https://user-images.githubusercontent.com/68539040/173881339-3c80725a-a9c5-4225-9efa-23073cbc8aa8.png"> <br />
<br /> 동작 방식의 구조는 다음과 같습니다. <br /> <br /> <img width="760" alt="msa05" src="https://user-images.githubusercontent.com/68539040/173970409-b6a07c3d-8ddc-46a3-8972-65606e1ab4a2.png"> <br />
<br /> 관리자가 페이지에 접속하고 Ajax를 이용하여 GET 메소드로 status api를 3초마다 요청을 보내 주문 내역을 계속 확인하다가.. <br />
완료 버튼을 누르면, <br />

<img width="760" alt="msa06" src="https://user-images.githubusercontent.com/68539040/173970559-8a89e082-7573-4260-9676-c67161bf320c.png"> <br />
<br /> PUT 메소드로 status api에 다음과 같은 json 데이터를 보내고 <br />
이 때, statusName이 ORDERED에서 DONE으로 바뀌게 되는 것 입니다.
<br /> <hr />

### 📍 회원 페이지 접속 화면
<br />
<img width="760" alt="msa07" src="https://user-images.githubusercontent.com/68539040/173970653-c022ab00-eb27-48ae-b1b8-3e0b1152ac06.png"> <br />
주문자는 웹브라우저를 통해 커피 주문 내역을 입력합니다. <br />
주문 번호는 시스템에서 자동으로 부여하고, 상단 빈칸에 회원명 입력, 메뉴 아이콘을 통해 커피 종류, 커피 개수를 입력하여 주문 버튼을 눌러 주문합니다.
<br />

동작 방식은 다음과 같습니다. <br /> <br />
<img width="760" alt="msa08" src="https://user-images.githubusercontent.com/68539040/174035965-df219a0e-dd88-489b-9ef7-9238a1991774.png"> <br />
고객이 고객 페이지에 접속 후, 메뉴를 고른 고객이 주문하기 버튼을 누르게 되면 <br />
Ajax를 이용해 POST 메소드로 order api에 다음과 같은 데이터를 전송하고
```
{
"_id" : "[주문 ID]",
"orderName" : "[메뉴]",
"userId" : "[고객 ID]",
"userName" : "[고객 이름]"
}
```
Ajax를 이용해 GET 메소드로 status api를 3초마다 호출해서 내 주문 내역을 확인합니다. <br />


주문 데이터를 전달 받은 Order 서비스는 회원의 이름을 이용해서 회원 확인 후 주문을 접수합니다. <br />
<br /> <img width="760" alt="im09" src="https://user-images.githubusercontent.com/68539040/174041667-08552d58-01d3-457a-8900-0642d2568ddc.png"> <br />
<br /> 주문이 접수될 때 큐잉 시스템(Kafka)을 통해 주문 정보를 발행하고 큐잉 시스템으로부터 Status 서비스는 메시지를 구독하는 구조 입니다. <br />
그래서 메시지를 전달 받은 Status 서비스는 전달받은 내용으로 주문 상태를 다음과 같이 추가합니다. <br /><hr />

### 📍 프로젝트 개발 환경
사용자가 이용하는 프론트엔드는 사이드카 패턴으로 구성되어있습니다. <br />
<br /> <img width="760" alt="im10" src="https://user-images.githubusercontent.com/68539040/174119488-38b698eb-f877-4c38-b062-97a9d64f0c34.png"> <br />
사용자가 접속하는 웹 서버와 Git에서 코드를 받아오는 puller 서버가 같은 볼륨을 공유하고 있으며, 개발자가 개발도구에서 개발, 변경한 코드를 Git으로 올리면 <br />
<br /> <img width="760" alt="im11" src="https://user-images.githubusercontent.com/68539040/174044756-93bc5c09-6846-4afa-bde3-e4d5ce2d0352.png"> <br />
<br /> 자동으로 puller가 해당 코드를 Git에서 받아와 볼륨에 저장하고, 저장된 코드는 웹 서버에 공유 되어있기 때문에 서비스에 바로 적용이 가능합니다. <br /><hr />

### 결론
마이크로서비스 아키텍처는 각 컴포넌트가 서비스라는 형태로 구현되고, API를 이용해 타 서비스와 통신을 합니다. <br />
배포 구조 관점에서도 각 서비스는 독립된 서버로 타 컴포넌트와의 의존성 없이 독립적으로 배포되는데, <br />
이것이 마이크로서비스 아키텍처의 가장 큰 장점 중 하나라고 느꼈습니다. <br />
예를 들어 커피 주문 상태 확인 서비스의 로직만 변경되었을 때, 기존 모놀리틱 아키텍처의 경우엔 전체 시스템을 다 재배포 해야하지만 <br />
마이크로서비스 아키텍처의 경우 변경이 있는 서비스 부분만 재배포 하면 됩니다. <br />
따라서 배포 속도가 빠르고, 전체 시스템의 영향도를 최소화한 수준에서 배포를 진행할 수 있었습니다.<br />

또 특정 모놀리틱의 경우 서비스의 부하가 많아져 성능 확장이 필요할 시 전체 서버의 수를 늘리거나 각 서버의 CPU 수를 늘려야 하지만,
마이크로서비스 아키텍처의 경우 부하를 많이 받는 서비스만 확장 해주면 문제가 해결되는 점 또한 큰 장점이 될 것 같습니다. <br />

그리고 클라우드환경과의 궁합이 좋습니다. Monolithic구조는 각각의 모듈들이 합쳐져 큰덩어리로 시스템이 구축되어 있습니다. <br />
사용량이 적은 모듈을 삭제한다고 하더라도 전체 시스템의 스펙은 변하지 않기 때문에, 사용량단위로 과금을 해야하는 클라우드 환경에서는 비효율적입니다. <br />
<br /><img width="600" alt="스크린샷 2022-06-16 오후 7 12 12" src="https://user-images.githubusercontent.com/68539040/174119939-db09f94a-c6a9-4f26-bfd0-f5e16c69dd02.png"><br />
<br /> 하지만 MSA 구조는 서비스단위로 기능을 분리해서 구축할 수 있기 때문에 <br />
사용하지 않는 기능 또는 사용량이 적은 기능을 축소해서 효율화시킬 수 있다는 장점이 있습니다. <br /> <hr />

### 🤔 But..
프로젝트를 진행하며 가장 큰 문제점이었던 점은 테스팅이었습니다. <br />
마이크로 서비스는 서비스들이 각각 분리가 되어 있고 다른 서비스에 대한 종속성을 가지고 있기 때문에 <br />
특정 사용자 시나리오 혹은 기능을 테스트 할 경우 여러 서비스에 걸쳐 테스트를 진행해야 합니다.  <br />
그래서 테스트 환경 구축이나 문제 발생 시 분리된 여러 시스템을 동시에 해결해야 하므로 테스팅의 복잡도가 올라갑니다. <br />
<br /> <img width="760" alt="스크린샷 2022-06-16 오후 7 13 10" src="https://user-images.githubusercontent.com/68539040/174119866-39fd9e08-c2ac-4367-a93b-ab461b6fca5c.png"><br />
<br /> 또 운영 관점에서는 서비스 별로 다른 기술을 사용할 수 있으며, 시스템이 서비스 단위로 잘게 나누어 지기 때문에  <br />
운영 대상 시스템 수가 늘어나고 이에 따라 필요 기술의 수도 늘어나게 된다는 문제점도 있습니다.  <br />

마이크로 서비스 아키텍처가 무조건 정답은 아닙니다. <br />
하나의 설계에 대한 레퍼런스 모델이고, 각 업무나 비지니스에 대한 특성 그리고 팀에 대한 성숙도와 가지고 있는 자원에 따라 <br />
적절한 아키텍쳐 스타일이 선택되어야 하며 
또 아키텍쳐는 처음 부터 완벽한 그림을 그리기 보다는 상황에 맞게 점진적으로 진화 시켜 나가는 모델이 바람직하다고 생각됩니다. <br />
그렇지만 그럼에도 불구하고 서비스들의 재사용성, 클라우드환경에 친화적이라는 큰 장점 때문에 <br />
현재 핫한 아키텍처가 된 것 같습니다. <br /><hr />

### 📝 개선방향
프로젝트 초기에 스프링 클라우드 히스트릭스를 이용하여 모니터링 시스템도 구현해보려 했지만 <br />
해당 버전에 호환되는 스프링 클라우드 버전에서 히스트릭스가 deprecated 되어 더 이상 제공되지 않았습니다. <br />
이는 차후 프로메테우스와 같은 오픈소스 모니터링 시스템을 적용해 문제를 해결할 계획이고 <br />
<br /> <img width="660" alt="스크린샷 2022-06-16 오후 7 15 51" src="https://user-images.githubusercontent.com/68539040/174121008-4e46f185-d48c-4545-b5c4-16477a85b15f.png"><br />
또 현재 프로젝트에서는 간단한 사용자 관리, 커피 주문과 상태에 대한 기능만 구현했지만 <br />
향후 기존의 실제 카페 시스템 처럼 마일리지, 추천 서비스 등 다양한 기능도 추가할 계획입니다. <br />
이러한 기능을 추가하기 위해서는 프로젝트의 DB도, 휘발성을 가지고 있는 인메모리 DB가 아닌 Mysql과 Oracle과 같은 DB로 바꿔줘야겠습니다. <br />

마지막으로 MSA에 대한 다양한 운영방식을 사용해봐야할 것 같습니다. <br />
본 프로젝트에서는 특정 서비스의 장애 상황에 대해서만 다뤄보았는데, 특정 서비스에 트래픽이 몰리는 상황에 대한 오토스케일링 처리나 
특정 사용자 그룹이 서비스의 특정 버전으로 유입되도록 하는 시나리오 등을 테스트 해보면 좀 더 MSA에 대한 이해도가 높아질 것이라 생각됩니다.

<br /><br />

